<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Miladev95 on Medium]]></title>
        <description><![CDATA[Stories by Miladev95 on Medium]]></description>
        <link>https://medium.com/@miladev95?source=rss-567b1067f520------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/proxy/1*TGH72Nnw24QL3iV9IOm4VA.png</url>
            <title>Stories by Miladev95 on Medium</title>
            <link>https://medium.com/@miladev95?source=rss-567b1067f520------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Mon, 06 Nov 2023 18:52:17 GMT</lastBuildDate>
        <atom:link href="https://medium.com/@miladev95/feed" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[Mastering Eloquent: An In-Depth Guide to Laravel Accessors and Mutators]]></title>
            <link>https://medium.com/@miladev95/mastering-eloquent-an-in-depth-guide-to-laravel-accessors-and-mutators-65bd7d9dfabc?source=rss-567b1067f520------2</link>
            <guid isPermaLink="false">https://medium.com/p/65bd7d9dfabc</guid>
            <category><![CDATA[mutator]]></category>
            <category><![CDATA[laravel]]></category>
            <category><![CDATA[accessor]]></category>
            <category><![CDATA[php-development]]></category>
            <category><![CDATA[php]]></category>
            <dc:creator><![CDATA[Miladev95]]></dc:creator>
            <pubDate>Wed, 25 Oct 2023 15:12:25 GMT</pubDate>
            <atom:updated>2023-10-25T15:12:25.653Z</atom:updated>
            <content:encoded><![CDATA[<p>Accessors and mutators are two powerful features of Laravel Eloquent that allow you to manipulate data before it is retrieved or saved to the database. Accessors are used to get the data, while mutators are used to set the data.</p><p>Accessors</p><p>Accessors are methods that are used to get the data from the database. They are typically used to format the data before it is returned to the user. For example, you could use an accessor to format a date or to capitalize a string.</p><p>To create an accessor, simply create a method that starts with the get prefix. For example, to create an accessor to format a date, you would create a method called getCreatedAtAttribute().</p><p>Mutators</p><p>Mutators are methods that are used to set the data in the database. They are typically used to validate the data or to format it before it is saved. For example, you could use a mutator to validate an email address or to hash a password.</p><p>To create a mutator, simply create a method that starts with the set prefix. For example, to create a mutator to validate an email address, you would create a method called setEmailAttribute().</p><p>Benefits of Using Accessors and Mutators</p><p>Accessors and mutators offer a number of benefits, including:</p><ul><li>Improved data consistency: Accessors and mutators can help you to ensure that your data is consistent by formatting it in a specific way before it is retrieved or saved to the database.</li><li>Reduced development time: Accessors and mutators can help you to reduce development time by providing a convenient way to format and validate data.</li><li>Improved code readability: Accessors and mutators can help to improve the readability of your code by grouping related code together.</li></ul><p>Examples of Using Accessors and Mutators</p><p>Here are some examples of how to use accessors and mutators in Laravel Eloquent:</p><pre>// Accessor to format a date<br>public function getCreatedAtAttribute()<br>{<br>    return $this-&gt;created_at-&gt;format(&#39;Y-m-d H:i:s&#39;);<br>}<br><br>// Mutator to validate an email address<br>public function setEmailAttribute($value)<br>{<br>    if (!filter_var($value, FILTER_VALIDATE_EMAIL)) {<br>        throw new ValidationException(&#39;The email address is not valid.&#39;);<br>    }<br>    $this-&gt;attributes[&#39;email&#39;] = $value;<br>}<br>// Accessor to capitalize a string<br>public function getNameAttribute()<br>{<br>    return ucfirst($this-&gt;name);<br>}<br>// Mutator to hash a password<br>public function setPasswordAttribute($value)<br>{<br>    $this-&gt;attributes[&#39;password&#39;] = bcrypt($value);<br>}</pre><p>Conclusion</p><p>Accessors and mutators are powerful features of Laravel Eloquent that can help you to improve the quality and readability of your code. By using accessors and mutators, you can ensure that your data is consistent, formatted correctly, and validated before it is saved to the database.</p><p>I hope this article has been helpful. If you have any questions, please leave a comment below.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=65bd7d9dfabc" width="1" height="1" alt="">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Laravel Resource Controllers]]></title>
            <link>https://medium.com/@miladev95/laravel-resource-controllers-6c8fc6d03dc7?source=rss-567b1067f520------2</link>
            <guid isPermaLink="false">https://medium.com/p/6c8fc6d03dc7</guid>
            <category><![CDATA[laravel-resource]]></category>
            <category><![CDATA[laravel]]></category>
            <category><![CDATA[php-development]]></category>
            <category><![CDATA[controller]]></category>
            <category><![CDATA[php]]></category>
            <dc:creator><![CDATA[Miladev95]]></dc:creator>
            <pubDate>Wed, 25 Oct 2023 15:10:37 GMT</pubDate>
            <atom:updated>2023-10-25T15:10:37.076Z</atom:updated>
            <content:encoded><![CDATA[<h3>What are resource controllers?</h3><p>Resource controllers are a convenient way to handle common CRUD (create, read, update, and delete) operations in Laravel. Laravel provides a set of pre-defined resource controllers that you can use out of the box, or you can create your own custom resource controllers.</p><h3>Benefits of using resource controllers</h3><p>There are a number of benefits to using resource controllers in Laravel, including:</p><ul><li>Reduced development time: Resource controllers can help you to reduce development time by providing a pre-built set of code for handling common CRUD operations.</li><li>Improved code organization: Resource controllers can help you to organize your code more effectively by grouping related CRUD operations together.</li><li>More consistent code: Resource controllers can help you to write more consistent code by following a standardized set of conventions.</li><li>Easier testing: Resource controllers can make it easier to test your code by providing a clear and concise way to interact with your application&#39;s resources.</li></ul><h3>Creating a resource controller</h3><p>To create a resource controller in Laravel, you can use the php artisan make:controller Artisan command. For example, to create a resource controller for the Post model, you would run the following command:</p><pre>php artisan make:controller PostController --resource</pre><p>This will create a new file called PostController.php in the app/Http/Controllers directory. The PostController class will extend the Laravel\Lumen\Routing\Controller class and will contain stub methods for each of the common CRUD operations.</p><h3>Using a resource controller</h3><p>Once you have created a resource controller, you can register it with Laravel&#39;s routing system. To do this, open the routes/web.php file and add the following route:</p><pre>Route::resource(&#39;posts&#39;, &#39;PostController&#39;);</pre><p>This route will map all of the resource controller&#39;s methods to the /posts URI. For example, the PostController@index() method will be mapped to the /posts URI, the PostController@store() method will be mapped to the /posts POST endpoint, and so on.</p><h3>Customizing a resource controller</h3><p>You can customize a resource controller by overriding any of the stub methods that are generated by the php artisan make:controller command. For example, you could override the PostController@store() method to add additional validation logic before storing a new post.</p><p>You can also add new methods to your resource controller. For example, you could add a PostController@search() method to allow users to search for posts.</p><h3>Conclusion</h3><p>Resource controllers are a powerful feature of Laravel that can help you to reduce development time, improve code organization, and write more consistent and testable code. If you are developing a Laravel application, I encourage you to consider using resource controllers for your common CRUD operations.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6c8fc6d03dc7" width="1" height="1" alt="">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Array Manipulation in PHP: Understanding array_reduce and array_walk]]></title>
            <link>https://medium.com/@miladev95/array-manipulation-in-php-understanding-array-reduce-and-array-walk-174b40a42faf?source=rss-567b1067f520------2</link>
            <guid isPermaLink="false">https://medium.com/p/174b40a42faf</guid>
            <category><![CDATA[array-reduce]]></category>
            <category><![CDATA[php]]></category>
            <category><![CDATA[array-walk]]></category>
            <category><![CDATA[php-development]]></category>
            <category><![CDATA[arrays]]></category>
            <dc:creator><![CDATA[Miladev95]]></dc:creator>
            <pubDate>Wed, 25 Oct 2023 11:53:16 GMT</pubDate>
            <atom:updated>2023-10-25T11:53:16.165Z</atom:updated>
            <content:encoded><![CDATA[<p>PHP offers a wide array of built-in functions to manipulate and process arrays efficiently. Among these functions, array_reduce and array_walk stand out as versatile tools for iterating through arrays and performing specific operations on their elements.</p><p>array_reduce</p><p>array_reduce is a function that iterates through an array and applies a user-defined callback function to each element, ultimately reducing the array to a single value. It takes three parameters:</p><ol><li>array: The input array to be processed.</li><li>callback: The callback function that will be applied to each element. It receives two arguments:</li><li>a. accumulator: The accumulated value from previous iterations.</li><li>b. currentValue: The current element being processed.</li><li>initial: An optional initial value for the accumulator. If not provided, the first element of the array is used as the initial value.</li></ol><p>The callback function should return the updated accumulated value, which is passed on to the next iteration. The final accumulated value is returned as the result of array_reduce.</p><p>Example usage of array_reduce:</p><pre>$numbers = [1, 2, 3, 4, 5];<br><br>$sum = array_reduce($numbers, function ($accumulator, $currentValue) {<br>    return $accumulator + $currentValue;<br>});<br>echo &quot;The sum of the array elements is: $sum&quot;;</pre><p>This code snippet calculates the sum of the elements in the ‘numbers’ array using array_reduce. The callback function adds the current element to the accumulator, and the final accumulated value represents the sum of all elements.</p><p>array_walk</p><p>array_walk is a function that iterates through an array and applies a user-defined callback function to each element. Unlike array_reduce, it doesn’t return a value but rather modifies the array in place. It takes three parameters:</p><ul><li>array: The input array to be processed.</li><li>callback: The callback function that will be applied to each element. It receives two arguments:</li><li>a. value: The current element’s value.</li><li>b. key: The current element’s key.</li><li>userdata: An optional parameter that can be passed to the callback function.</li></ul><p>The callback function can modify the array elements or perform any desired operation based on the element’s value and key.</p><p>Example usage of array_walk:</p><pre>$fruits = [&#39;apple&#39;, &#39;orange&#39;, &#39;banana&#39;];<br>array_walk($fruits, function (&amp;$value, $key) {<br>    $value = strtoupper($value);<br>});<br>print_r($fruits);</pre><p>This code snippet converts all elements in the ‘fruits’ array to uppercase using array_walk. The callback function modifies the element’s value directly using the ‘&amp;’ reference operator.</p><p>Key Differences between array_reduce and array_walk</p><ul><li>Purpose: array_reduce is used to reduce an array to a single value, while array_walk is used to modify the array in place or perform actions based on its elements.</li><li>Return Value: array_reduce returns a single value, while array_walk doesn’t return any value.</li><li>Element Modification: array_reduce doesn’t modify the original array, while array_walk can modify the array elements directly.</li></ul><p>Conclusion</p><p>array_reduce and array_walk are both powerful tools for iterating through arrays and performing specific operations on their elements. The choice between the two depends on the desired outcome: array_reduce for reducing an array to a single value and array_walk for modifying the array or performing actions based on its elements.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=174b40a42faf" width="1" height="1" alt="">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Differences Between ob_flush() and flush() in PHP]]></title>
            <link>https://medium.com/@miladev95/differences-between-ob-flush-and-flush-in-php-487f02c6dcaa?source=rss-567b1067f520------2</link>
            <guid isPermaLink="false">https://medium.com/p/487f02c6dcaa</guid>
            <category><![CDATA[php-developers]]></category>
            <category><![CDATA[ob-flush]]></category>
            <category><![CDATA[php-development]]></category>
            <category><![CDATA[php]]></category>
            <category><![CDATA[flush]]></category>
            <dc:creator><![CDATA[Miladev95]]></dc:creator>
            <pubDate>Wed, 25 Oct 2023 11:50:18 GMT</pubDate>
            <atom:updated>2023-10-25T11:50:18.598Z</atom:updated>
            <content:encoded><![CDATA[<p>PHP has two functions for flushing output buffers: ob_flush() and flush(). Both functions are used to send the contents of the output buffer to the browser, but there are some key differences between them.</p><p>ob_flush()</p><p>ob_flush() flushes the output buffer for the current PHP script. This means that any output that has been buffered since the last call to ob_start() will be sent to the browser. ob_flush() does not affect any other PHP scripts on the page.</p><p>ob_flush() is typically used when you want to send output to the browser before the current PHP script has finished executing. For example, you might use ob_flush() to send progress updates to the user while a long-running script is executing.</p><p>flush()</p><p>flush() flushes all output buffers, including the output buffer for the current PHP script and the output buffers for any other PHP scripts that are currently executing on the page. flush() also flushes the output buffers of the underlying web server.</p><p>flush() is typically used when you need to send all output to the browser immediately. For example, you might use flush() to send a redirect to the user after a login attempt.</p><h3>When to use ob_flush() vs flush()</h3><p>In general, you should use ob_flush() if you only need to flush the output buffer for the current PHP script. If you need to flush the output buffers for all PHP scripts on the page, or if you need to flush the output buffers of the underlying web server, then you should use flush().</p><p>Here are some specific examples of when to use each function:</p><p>Use ob_flush() to:</p><ul><li>Send progress updates to the user while a long-running script is executing.</li><li>Send a partial response to the user before the current PHP script has finished executing.</li><li>Flush the output buffer for a specific PHP script, without affecting the output buffers for any other PHP scripts on the page.</li></ul><p>Use flush() to:</p><ul><li>Send all output to the browser immediately.</li><li>Flush the output buffers for all PHP scripts on the page, including the output buffer for the current PHP script.</li><li>Flush the output buffers of the underlying web server.</li></ul><h3>Example usage</h3><pre>// ob_flush() example<br>ob_start();<br><br>// Output some text to the buffer.<br>echo &#39;This text will be buffered.&#39;;<br>// Flush the buffer to the browser.<br>ob_flush();<br>// Output more text to the buffer.<br>echo &#39;This text will also be buffered.&#39;;<br>// End buffering and send any remaining output to the browser.<br>ob_end_flush();<br><br>// flush() example<br>flush();<br><br>// Output some text to the browser.<br>echo &#39;This text will be sent to the browser immediately.&#39;;</pre><h3>Conclusion</h3><p>ob_flush() and flush() are both useful functions for flushing output buffers in PHP. However, there are some key differences between the two functions. ob_flush() only flushes the output buffer for the current PHP script, while flush() flushes the output buffers for all PHP scripts on the page and the underlying web server.</p><p>Which function you use depends on your specific needs. If you only need to flush the output buffer for the current PHP script, then you should use ob_flush(). If you need to flush the output buffers for all PHP scripts on the page, or if you need to flush the output buffers of the underlying web server, then you should use flush().</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=487f02c6dcaa" width="1" height="1" alt="">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[How to Improve Code Quality With PHPStan]]></title>
            <link>https://medium.com/@miladev95/how-to-improve-code-quality-with-phpstan-959b8e0d7ce7?source=rss-567b1067f520------2</link>
            <guid isPermaLink="false">https://medium.com/p/959b8e0d7ce7</guid>
            <category><![CDATA[php-developers]]></category>
            <category><![CDATA[phpstan]]></category>
            <category><![CDATA[php-development]]></category>
            <category><![CDATA[php7]]></category>
            <category><![CDATA[php]]></category>
            <dc:creator><![CDATA[Miladev95]]></dc:creator>
            <pubDate>Wed, 25 Oct 2023 11:47:03 GMT</pubDate>
            <atom:updated>2023-10-25T11:47:03.929Z</atom:updated>
            <content:encoded><![CDATA[<p>PHPStan is a static analysis tool that can help you to improve the quality of your PHP code. It works by analyzing your PHP code and identifying potential errors and problems before you run your code.</p><p>PHPStan can help you to identify a variety of problems in your code, including:</p><ul><li>Type errors: PHPStan can identify type errors in your code, such as passing the wrong type of argument to a function.</li><li>Unused variables: PHPStan can identify unused variables in your code, which can help you to reduce clutter and make your code more efficient.</li><li>Unreachable code: PHPStan can identify unreachable code in your code, which can help you to remove dead code and make your code more concise.</li><li>Potential bugs: PHPStan can identify potential bugs in your code, such as null pointer exceptions and division by zero errors.</li></ul><p>PHPStan can also be used to enforce coding standards and best practices. For example, PHPStan can check that your code follows the PSR-12 coding standard and that it uses consistent naming conventions.</p><p>To use PHPStan, you first need to install it. You can do this using Composer:</p><pre>composer require phpstan/phpstan</pre><p>Once PHPStan is installed, you can run it by executing the following command:</p><pre>vendor/bin/phpstan analyse</pre><p>PHPStan will analyze your code and generate a report of any errors or problems that it finds. You can then use this report to fix the problems in your code.</p><p>Here are some tips for improving your code quality with PHPStan:</p><ul><li>Start by running PHPStan with the lowest level of severity. This will help you to identify the most important problems in your code.</li><li>Once you have fixed the most important problems, you can gradually increase the severity level to identify less important problems.</li><li>Use PHPStan to enforce coding standards and best practices. This will help you to write more consistent and maintainable code.</li><li>Integrate PHPStan with your continuous integration (CI) pipeline. This will help you to catch errors and problems in your code early, before you merge your code into the main branch.</li></ul><p>Overall, PHPStan is a powerful tool that can help you to improve the quality of your PHP code. By using PHPStan, you can identify and fix errors and problems in your code before you run it, which can save you time and effort in the long run.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=959b8e0d7ce7" width="1" height="1" alt="">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[PHP ORM: Data Mapper vs Active Record]]></title>
            <link>https://medium.com/@miladev95/php-orm-data-mapper-vs-active-record-61c096f3e093?source=rss-567b1067f520------2</link>
            <guid isPermaLink="false">https://medium.com/p/61c096f3e093</guid>
            <category><![CDATA[activerecord]]></category>
            <category><![CDATA[php]]></category>
            <category><![CDATA[php-development]]></category>
            <category><![CDATA[orm]]></category>
            <category><![CDATA[data-mapper]]></category>
            <dc:creator><![CDATA[Miladev95]]></dc:creator>
            <pubDate>Wed, 25 Oct 2023 11:43:22 GMT</pubDate>
            <atom:updated>2023-10-25T11:43:22.454Z</atom:updated>
            <content:encoded><![CDATA[<p>Object-relational mapping (ORM) is a programming technique that maps entities in a database to objects in a programming language. ORMs provide a layer of abstraction between the database and the application, which can make the code easier to read, write, and maintain.</p><p>There are two main ORM patterns in PHP: data mapper and active record.</p><p>Data mapper</p><p>The data mapper pattern is a more traditional ORM pattern. It involves creating a dedicated class for each table in the database. These classes are responsible for mapping the database rows to objects and vice versa.</p><p>To use the data mapper pattern, you would typically first create a data mapper class for each table in your database. These classes would have methods for creating, reading, updating, and deleting objects.</p><p>To create a new object, you would call the data mapper class’s create() method. This method would take the object&#39;s attributes as arguments and create a new row in the database.</p><p>To read an object, you would call the data mapper class’s find() method. This method would take the object&#39;s primary key as an argument and return the corresponding object from the database.</p><p>To update an object, you would call the data mapper class’s update() method. This method would take the object&#39;s updated attributes as arguments and update the corresponding row in the database.</p><p>To delete an object, you would call the data mapper class’s delete() method. This method would take the object&#39;s primary key as an argument and delete the corresponding row from the database.</p><p>Active record</p><p>The active record pattern is a more modern ORM pattern. It involves creating a class for each table in the database, but the objects of these classes are also responsible for interacting with the database.</p><p>To use the active record pattern, you would typically create a class for each table in your database. These classes would have attributes that map to the columns in the database. They would also have methods for creating, reading, updating, and deleting objects.</p><p>To create a new object, you would simply create an instance of the class and set its attributes. The object would then automatically be saved to the database.</p><p>To read an object, you would simply create an instance of the class and set its primary key. The object would then be populated with the data from the database.</p><p>To update an object, you would simply update its attributes and call the save() method. The object would then be updated in the database.</p><p>To delete an object, you would simply call the delete() method on the object. The object would then be deleted from the database.</p><p>Advantages and disadvantages of each pattern</p><p>The data mapper pattern has the following advantages:</p><ul><li>It is more flexible and scalable than the active record pattern.</li><li>It is easier to test than the active record pattern.</li><li>It is easier to maintain than the active record pattern.</li></ul><p>The data mapper pattern has the following disadvantages:</p><ul><li>It is more complex than the active record pattern.</li><li>It can be more verbose than the active record pattern.</li></ul><p>The active record pattern has the following advantages:</p><ul><li>It is simpler than the data mapper pattern.</li><li>It is more concise than the data mapper pattern.</li><li>It is easier to use than the data mapper pattern.</li></ul><p>The active record pattern has the following disadvantages:</p><ul><li>It is less flexible and scalable than the data mapper pattern.</li><li>It is more difficult to test than the data mapper pattern.</li><li>It can be more difficult to maintain than the data mapper pattern.</li></ul><p>Which pattern should you choose?</p><p>The best ORM pattern for you will depend on your specific needs. If you need a flexible and scalable ORM, then the data mapper pattern is a good choice. If you need a simple and easy-to-use ORM, then the active record pattern is a good choice.</p><p>Many popular PHP frameworks, such as Laravel and Symfony, use the active record pattern. However, it is important to be aware of the advantages and disadvantages of each pattern before you choose one.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=61c096f3e093" width="1" height="1" alt="">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Test-Driven Development (TDD) with PHP, PHPUnit, and Laravel]]></title>
            <link>https://medium.com/@miladev95/test-driven-development-tdd-with-php-phpunit-and-laravel-3d8b4f48739c?source=rss-567b1067f520------2</link>
            <guid isPermaLink="false">https://medium.com/p/3d8b4f48739c</guid>
            <category><![CDATA[laravel]]></category>
            <category><![CDATA[tdd]]></category>
            <category><![CDATA[test-driven-design]]></category>
            <category><![CDATA[php]]></category>
            <category><![CDATA[phpunit]]></category>
            <dc:creator><![CDATA[Miladev95]]></dc:creator>
            <pubDate>Mon, 23 Oct 2023 10:53:35 GMT</pubDate>
            <atom:updated>2023-10-23T10:53:35.694Z</atom:updated>
            <content:encoded><![CDATA[<p><strong>Introduction</strong></p><p>Test-Driven Development (TDD) is a software development practice that has gained immense popularity for its ability to improve code quality, reduce bugs, and enhance the maintainability of software projects. When applied to PHP, particularly in combination with Laravel and PHPUnit, TDD can streamline the development process and lead to more robust applications. In this article, we will explore the fundamentals of Test-Driven Development in the context of PHP development with Laravel and PHPUnit.</p><h3>What is Test-Driven Development (TDD)?</h3><p>Test-Driven Development (TDD) is a software development methodology that revolves around the idea of writing tests before writing code. The TDD process can be broken down into the following steps:</p><ol><li>Write a failing test that describes the behavior you want to implement.</li><li>Write the minimal code required to make the test pass.</li><li>Refactor the code while ensuring that all tests still pass.</li></ol><p>This cycle continues iteratively, with developers constantly adding new tests, writing code to satisfy those tests, and refining their code as necessary. TDD provides a safety net that ensures that changes or new features do not break existing functionality.</p><h3>Setting Up Your Environment</h3><p>Before diving into TDD with PHP, Laravel, and PHPUnit, you need to set up your development environment:</p><ol><li>PHP: Make sure you have PHP installed on your system. You can download it from the <a href="https://www.php.net/downloads.php">official PHP website</a>.</li><li>Composer: Composer is a dependency management tool for PHP. Install it by following the instructions on the <a href="https://getcomposer.org/download/">Composer website</a>.</li><li>Laravel: Install Laravel using Composer with the following command:</li></ol><pre>composer global require laravel/installer</pre><p>4. PHPUnit: PHPUnit is a testing framework for PHP. You can install it using Composer:</p><pre>composer require --dev phpunit/phpunit</pre><h3>Creating a Laravel Project</h3><p>To practice TDD with Laravel, you need a Laravel project to work on. You can create a new Laravel project using the following command:</p><pre>laravel new your-project-name</pre><h3>Writing Your First Test</h3><p>Let&#39;s start by writing a simple test. In Laravel, tests are typically located in the tests directory. To create a new test, you can use the make:test Artisan command:</p><pre>php artisan make:test MyFirstTest</pre><p>This will generate a new test file in the tests directory.</p><pre>&lt;?php<br><br>namespace Tests\Unit;<br><br>use Tests\TestCase;<br><br>class MyFirstTest extends TestCase<br>{<br>    /**<br>     * A basic test example.<br>     *<br>     * @return void<br>     */<br>    public function test_example()<br>    {<br>        $this-&gt;assertTrue(true);<br>    }<br>}</pre><p>In this example, we have created a simple test called test_example that asserts that true is, in fact, true.</p><h3>Running Tests</h3><p>To run your tests, you can use PHPUnit, which Laravel integrates seamlessly. Simply run the following command in your project&#39;s root directory:</p><pre>./vendor/bin/phpunit</pre><p>You should see output indicating that the test passed.</p><h3>The TDD Cycle in Action</h3><p>Now, let&#39;s demonstrate the TDD cycle in action by implementing a simple feature. Suppose we want to create a function that adds two numbers together. We start with a failing test:</p><pre>public function test_adds_two_numbers()<br>{<br>    $result = add(2, 3);<br>    $this-&gt;assertEquals(5, $result);<br>}</pre><p>In this test, we&#39;re asserting that calling a hypothetical add function with arguments 2 and 3 should return 5. This test will fail because the add function doesn&#39;t exist yet.</p><p>To make the test pass, we implement the add function in our code:</p><pre>function add($a, $b)<br>{<br>    return $a + $b;<br>}</pre><p>After implementing the code, we run the test again. If the test passes, we can proceed to the final step of the TDD cycle: refactoring and improving the code if necessary.</p><h3>Conclusion</h3><p>Test-Driven Development (TDD) is a powerful approach for PHP developers, particularly when working with Laravel and PHPUnit. It encourages writing clean, maintainable code and helps catch bugs early in the development process. By following the TDD cycle—writing failing tests, implementing code, and refactoring—you can build high-quality, reliable software. As you become more proficient with TDD, you&#39;ll find that your PHP applications become more robust and easier to maintain, making you a more effective and confident developer.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3d8b4f48739c" width="1" height="1" alt="">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A Simple Request Router written in PHP]]></title>
            <link>https://medium.com/@miladev95/a-simple-request-router-written-in-php-40b733f318b4?source=rss-567b1067f520------2</link>
            <guid isPermaLink="false">https://medium.com/p/40b733f318b4</guid>
            <category><![CDATA[php]]></category>
            <category><![CDATA[router]]></category>
            <category><![CDATA[routing]]></category>
            <category><![CDATA[php-router]]></category>
            <category><![CDATA[php-development]]></category>
            <dc:creator><![CDATA[Miladev95]]></dc:creator>
            <pubDate>Mon, 23 Oct 2023 10:38:22 GMT</pubDate>
            <atom:updated>2023-10-23T10:38:22.816Z</atom:updated>
            <content:encoded><![CDATA[<p>A request router is a component in a web application that is responsible for routing incoming requests to the appropriate controller. This allows you to separate your application&#39;s logic into different controllers, which makes your code more organized and easier to maintain.</p><p>Here is a simple request router written in PHP:</p><pre>class Router<br>{<br>    private $routes = [];<br><br>    public function addRoute($method, $uri, $controller)<br>    {<br>        $this-&gt;routes[$method][$uri] = $controller;<br>    }<br><br>    public function match($request)<br>    {<br>        $method = $request-&gt;getMethod();<br>        $uri = $request-&gt;getPathInfo();<br><br>        if (isset($this-&gt;routes[$method][$uri])) {<br>            return $this-&gt;routes[$method][$uri];<br>        }<br><br>        return null;<br>    }<br><br>    public function dispatch($request)<br>    {<br>        $controller = $this-&gt;match($request);<br><br>        if ($controller !== null) {<br>            $controller-&gt;handle($request);<br>        } else {<br>            header(&#39;HTTP/1.1 404 Not Found&#39;);<br>            echo &#39;Not Found&#39;;<br>        }<br>    }<br>}</pre><p>To use the router, you would first need to add routes to it. For example, the following code adds a route for the / URI that will call the HomeController class&#39;s index() method:</p><pre>$router = new Router();<br>$router-&gt;addRoute(&#39;GET&#39;, &#39;/&#39;, &#39;HomeController@index&#39;);</pre><p>Once you have added routes to the router, you can then dispatch requests to it. For example, the following code will dispatch the current request to the router:</p><pre>$router-&gt;dispatch();</pre><p>The router will then match the request to a route and call the appropriate controller.</p><p>This is just a simple example of a request router. You can extend this router to support more features, such as routing requests based on parameters or matching routes using regular expressions.</p><p>Here are some additional tips for writing a request router:</p><ul><li>Use a consistent naming convention for your routes. This will make it easier to read and maintain your code.</li><li>Group similar routes together. This will make your code more organized and easier to understand.</li><li>Use comments to document your routes. This will help other developers understand how to use your router.</li><li>Test your router thoroughly before using it in production. This will help to prevent problems from occurring in production.</li></ul><p>Overall, a request router is a valuable tool that can help you to organize and maintain your PHP code.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=40b733f318b4" width="1" height="1" alt="">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[PHP: trim, htmlspecialchars, and __call built-in functions]]></title>
            <link>https://medium.com/@miladev95/php-trim-htmlspecialchars-and-call-built-in-functions-1826c87a5f68?source=rss-567b1067f520------2</link>
            <guid isPermaLink="false">https://medium.com/p/1826c87a5f68</guid>
            <category><![CDATA[magic-method]]></category>
            <category><![CDATA[htmlspecialchar]]></category>
            <category><![CDATA[php-development]]></category>
            <category><![CDATA[trim]]></category>
            <category><![CDATA[php]]></category>
            <dc:creator><![CDATA[Miladev95]]></dc:creator>
            <pubDate>Mon, 23 Oct 2023 10:35:51 GMT</pubDate>
            <atom:updated>2023-10-23T10:35:51.946Z</atom:updated>
            <content:encoded><![CDATA[<p>trim()</p><p>The trim() function is a PHP built-in function that removes whitespace from the beginning and end of a string. Whitespace includes spaces, tabs, and newlines.</p><p>The trim() function takes one or two arguments:</p><ul><li>$string: The string to remove whitespace from.</li><li>$character_mask: A string containing the characters to remove from the beginning and end of the string. If this argument is omitted, the default whitespace characters will be removed.</li></ul><p>The trim() function returns a string with the whitespace removed from the beginning and end.</p><p>Here are some examples of how to use the trim() function:</p><pre>// Remove all whitespace from the beginning and end of the string<br>$string = trim(&#39;   Hello, world!   &#39;);<br>echo $string; // Output: &#39;Hello, world!&#39;<br><br>// Remove the characters &#39;a&#39; and &#39;b&#39; from the beginning and end of the string<br>$string = trim(&#39;abHello, world!ab&#39;, &#39;ab&#39;);<br>echo $string; // Output: &#39;Hello, world!&#39;</pre><p>htmlspecialchars()</p><p>The htmlspecialchars() function is a PHP built-in function that converts special characters to HTML entities. This function is useful for preventing cross-site scripting (XSS) attacks.</p><p>The htmlspecialchars() function takes three or four arguments:</p><ul><li>$string: The string to convert special characters in.</li><li>$flags: A bitmask of flags that control how the string is converted.</li><li>$encoding: The encoding of the string. If this argument is omitted, the default encoding will be used.</li><li>$double_encode: A boolean value that indicates whether to double-encode existing HTML entities.</li></ul><p>The htmlspecialchars() function returns a string with the special characters converted to HTML entities.</p><p>Here are some examples of how to use the htmlspecialchars() function:</p><pre>// Convert the special characters &#39;&lt;&#39;, &#39;&gt;&#39;, and &#39;&amp;&#39; to HTML entities<br>$string = htmlspecialchars(&#39;&lt;p&gt;&amp;This is a paragraph.&lt;/p&gt;&#39;);<br>echo $string; // Output: &#39;&amp;lt;p&amp;gt;&amp;amp;This is a paragraph.&amp;amp;&amp;lt;/p&amp;gt;&#39;<br><br>// Convert the special characters &#39;&lt;&#39;, &#39;&gt;&#39;, and &#39;&amp;&#39; to HTML entities, using the UTF-8 encoding<br>$string = htmlspecialchars(&#39;&lt;p&gt;&amp;This is a paragraph.&lt;/p&gt;&#39;, ENT_QUOTES, &#39;UTF-8&#39;);<br>echo $string; // Output: &#39;&amp;lt;p&amp;gt;&amp;amp;This is a paragraph.&amp;amp;&amp;lt;/p&amp;gt;&#39;<br><br>// Convert the special characters &#39;&lt;&#39;, &#39;&gt;&#39;, and &#39;&amp;&#39; to HTML entities, and double-encode existing HTML entities<br>$string = htmlspecialchars(&#39;&lt;p&gt;&amp;This is a paragraph.&lt;/p&gt;&#39;, ENT_QUOTES, &#39;UTF-8&#39;, true);<br>echo $string; // Output: &#39;&amp;lt;p&amp;gt;&amp;amp;amp;This is a paragraph.&amp;amp;amp;&amp;lt;/p&amp;gt;&#39;</pre><p>__call()</p><p>The __call() magic method is a PHP built-in method that is called when a method is called on an object that does not exist.</p><p>The __call() magic method takes two arguments:</p><ul><li>$method: The name of the method that was called.</li><li>$arguments: An array of arguments that were passed to the method.</li></ul><p>The __call() magic method can be used to implement dynamic method dispatch. This can be useful for implementing features such as method overloading and method chaining.</p><p>Here is an example of how to use the __call() magic method:</p><pre>class MyClass<br>{<br>    public function __call($method, $arguments)<br>    {<br>        // If the method exists on the parent class, call it<br>        if (method_exists(get_parent_class($this), $method)) {<br>            return call_parent($method, $arguments);<br>        }<br><br>        // Otherwise, throw an exception<br>        throw new Exception(&#39;Method not found: &#39; . $method);<br>    }<br>}<br>$my_class = new MyClass();<br>// Call a method that does not exist<br>$my_class-&gt;my_method(); // This will throw an exception<br>// Call a method that exists on the parent class<br>$my_class-&gt;parent_method(); // This will call the parent class&#39;s `parent_method()` method</pre><p>The __call() magic method is a powerful tool that can be used to implement dynamic method dispatch. However, it should be used with caution, as it can be easy to misuse.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1826c87a5f68" width="1" height="1" alt="">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Push notifications with Laravel]]></title>
            <link>https://medium.com/@miladev95/push-notifications-with-laravel-b2d837b8c653?source=rss-567b1067f520------2</link>
            <guid isPermaLink="false">https://medium.com/p/b2d837b8c653</guid>
            <category><![CDATA[laravel]]></category>
            <category><![CDATA[fcm]]></category>
            <category><![CDATA[laravel-framework]]></category>
            <category><![CDATA[php]]></category>
            <category><![CDATA[fcm-push-notification]]></category>
            <dc:creator><![CDATA[Miladev95]]></dc:creator>
            <pubDate>Mon, 23 Oct 2023 10:33:02 GMT</pubDate>
            <atom:updated>2023-10-23T10:33:02.546Z</atom:updated>
            <content:encoded><![CDATA[<p>Push notifications are messages that are sent to users’ devices, even when the app is closed or not in use. They can be used to notify users about new messages, events, or other updates.</p><p>Laravel makes it easy to send push notifications using the Notification class. This class provides a unified interface for sending notifications to a variety of channels, including email, SMS, and push notifications.</p><p>To send push notifications in Laravel, you will need to install a Laravel push notification package. There are a number of different packages available, such as LaravelFCM and LaravelPusher.</p><p>Once you have installed a push notification package, you will need to configure it. This will typically involve providing your app’s credentials for the push notification service that you are using.</p><p>Once your push notification package is configured, you can start sending push notifications using the Notification class. To do this, you will need to create a notification class that extends the Notification class.</p><p>In your notification class, you will need to override the toMail() and via() methods. The toMail() method will generate the email content for the notification, and the via() method will specify the channels that you want to send the notification to.</p><p>For example, the following code shows a simple notification class that sends a push notification:</p><pre>use Illuminate\Notifications\Notification;<br>use LaravelFCM\Facades\FCM;<br><br>class PushNotification extends Notification<br>{<br>    public function __construct($message)<br>    {<br>        $this-&gt;message = $message;<br>    }<br>    public function toMail($notifiable)<br>    {<br>        // Generate the email content for the notification<br>    }<br>    public function via($notifiable)<br>    {<br>        return [&#39;fcm&#39;];<br>    }<br>    public function toFCM($notifiable)<br>    {<br>        $data = [<br>            &#39;title&#39; =&gt; &#39;Push Notification&#39;,<br>            &#39;body&#39; =&gt; $this-&gt;message,<br>        ];<br>        return FCM::to($notifiable-&gt;fcm_token)<br>            -&gt;notification($data)<br>            -&gt;send();<br>    }<br>}</pre><p>To send the push notification, you would simply call the notify() method on the user that you want to send the notification to. For example, the following code shows how to send a push notification to a user with the ID of 1:</p><pre>$user = User::find(1);<br>$user-&gt;notify(new PushNotification(&#39;This is a push notification!&#39;));</pre><p>Once you have sent the push notification, the user will receive a message on their device, even if the app is closed or not in use.</p><p>Here are some additional tips for sending push notifications with Laravel:</p><ul><li>Make sure to use a trusted push notification service. There are a number of different push notification services available, but some of them are more reliable than others.</li><li>Segment your users. This will allow you to send more targeted and relevant push notifications.</li><li>Personalize your push notifications. This will make them more likely to be opened and read.</li><li>Test your push notifications thoroughly before sending them to your users. This will help to ensure that they are being sent and received correctly.</li></ul><p>Overall, push notifications are a powerful tool that can be used to notify users about important updates and events. Laravel makes it easy to send push notifications, and there are a number of different packages available to help you get started.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b2d837b8c653" width="1" height="1" alt="">]]></content:encoded>
        </item>
    </channel>
</rss>